<Justificación del Diseño del Software>

Para armar el juego, pensé que lo mejor era separar todo por responsabilidades, como pedía el práctico. La idea principal era que cada "pieza" del código tuviera un solo trabajo y lo hiciera bien. Así, todo el programa queda mucho más ordenado y es más fácil de probar después.

Arranqué por las clases más simples, que son básicamente para guardar datos. Checker es la ficha, y lo único que sabe es su _color_. No tiene idea de dónde está en el tablero. Player es parecido, solo guarda el _name_ del jugador y el _color_ de las fichas que usa. Luego hice Dice, que se encarga de todo lo que tenga que ver con los dados: tiene el método roll() para tirarlos, y get_moves() que es clave, porque se fija si salieron dobles y te devuelve cuatro movimientos en vez de dos.

La clase Board es la más importante y la que tiene la lógica más pesada. Es como si fuera el árbitro y el tablero al mismo tiempo. Para guardar dónde está cada ficha usé el atributo _points_, que es una lista que contiene 24 listas más (una por cada triángulo del tablero). También tiene el _bar_ para las fichas que van comiendo. Los métodos de esta clase, como is_valid_move o reenter_checker, tienen todas las reglas del juego: validan si te podés mover ahí, si la dirección es correcta, si el punto está bloqueado por el oponente, o si podés sacar una ficha de la barra.

Por último, la clase BackgammonGame es la que "dirige la orquesta". Esta clase no sabe cómo funcionan las reglas (de eso se encarga el Board), pero sabe cuándo pasa cada cosa. Se encarga de crear el tablero y los jugadores, maneja de quién es el turno (switch_turn), y le pide a Dice que tire los dados. Cuando un jugador quiere moverse, BackgammonGame guarda los dados disponibles en _moves_ y le pregunta al Board si el movimiento es válido. Si el Board (el árbitro) le da el OK, recién ahí BackgammonGame le ordena que mueva la ficha y tacha ese dado de la lista _moves_. Esta separación me pareció la mejor forma de que todo quede prolijo.